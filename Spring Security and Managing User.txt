Spring can implement security measures using servlets or applets in the spring MVC web app. We are doing the servlet based one here.
We will be continuing with the same KushalDynamicWebApplication program. Now we are gonna make a login form so that the users will have to
login first and then only be able to create an offer.

We are gonna use filters for the security. Filter is like a layer that will be introduced before the DispatcherServlet. DispatcherServlet is
the entry point to our web application.

Right click the project and New > Others > Web > Filter
Make a package called com.kushal.spring.web.filters and Class name as TestFilter. This filter has nothing to do with Spring but spring will use
this filter to implement the security stuffs.



It will look like this:


package com.kushal.springframework.web.filters;

import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

/**
 * Servlet Filter implementation class TestFilter
 */
public class TestFilter implements Filter {

    /**
     * Default constructor. 
     */
    public TestFilter() {
        // TODO Auto-generated constructor stub
    }

	/**
	 * @see Filter#destroy()
	 */
	public void destroy() {
		// TODO Auto-generated method stub
	}

	/**
	 * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain)
	 */
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		// TODO Auto-generated method stub
		// place your code here

		// pass the request along the filter chain
		chain.doFilter(request, response);
	}

	/**
	 * @see Filter#init(FilterConfig)
	 */
	public void init(FilterConfig fConfig) throws ServletException {
		// TODO Auto-generated method stub
	}

}


Here destroy and init are the important methods. Also in the doFilter method, we do whatever the filter needs to do and there is also a
chain.doFilter method, which is like a filter chain and in there the dispatcherServlet will go.
Furthermore, if I add the following line in the doFilter method, it will print out the url address

		System.out.println(((HttpServletRequest)request).getRequestURL()); // Here the request is cast into HttpServletRequest and its method
		getRequestURL is invoked on it.

This filter will also updated in the web.xml file as:

<filter>
    <display-name>TestFilter</display-name>
    <filter-name>TestFilter</filter-name>
    <filter-class>com.kushal.springframework.web.filters.TestFilter</filter-class>
  </filter>
  <filter-mapping>
    <filter-name>TestFilter</filter-name>
    <url-pattern>/*</url-pattern>  //   /* to intercept all the url
  </filter-mapping>




Adding a Spring security Filter:
---------------------------------

Now we are gonna use spring security to provide the security features and manage users. 
We need to add the following dependencies:
			1. spring-security-core (there might be issues with the version of spring security and spring beans)
			2. spring-security-web
			3. spring-security-config

		Do I need to upadate the project?

We don't need the old filter that we added before, so we are gonna delete the TestFilter class and also make sure to delete the filter stuffs 
in the web.xml file.

We are gonna add a filter now using the standard spring class.

Steps:

1. Right click the project > New > Others > Web > Filters and this time instead of creating a class we are gonna use the existing class. Check the 
existing filter Class and browse for: DelegatingFilterProxy and click next. Put the name as springSecurityFilterChain, here name is very important and 
is case sensitive. Then click finish.

This should be updated in the web.xml file as:

	  <filter>
    <display-name>springSecurityFilterChain</display-name>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
  </filter>
  <filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern> // URL pattern has been modified to meet the needs.
  </filter-mapping>

  

2. Now we need to add the config file for security in the config package. Add a spring bean config file in there and name it as
	security-config.xml.
	Now go to the web.xml file, add the classpath for this new config file as:
					classpath:com/kushal/springframework/web/config/security-context.xml

	In this config file's namespace, check the security check box. And in the sec tab, right click the beans and select
		Insert authentication-manager. Right click the authentication-manager and select security authentication-provider.
		Then right click the security authentication-provider and select user-service and again right click the user-service and select
		Insert security:user.
		Now in here, type admin for the authority (just made up for now)
					 type, say Kushal for name and type, letmein for password.

		Lets create one more user.

		In the source code, it will look like this:



		<security:authentication-manager>
		<security:authentication-provider>
			<security:user-service>
				<security:user name="Kushal" authorities="admin"
					password="letmein" />
					<security:user name="John" authorities="admin"
					password="passmein" />
			</security:user-service>
		</security:authentication-provider>
	</security:authentication-manager>


	We have hard coded for now.

	Now we need to specify what part of the web site are under access control. Go back the sec tab in the same config file and right click the bean and
	select the security-http. In the right, scroll down and check the use expressions as true (we are gonna use expressions).
	Right click the security:http and select the intercept url. In the right side, put the pattern as /** to deny access to all the url to the websites.
	Then we will selectively allow access.

	In the access, type as denyAll (case sensitive)

	Again right click the http bean and select the form login element.
	The source code will look like:

		<security:http use-expressions="true">
		<security:intercept-url pattern="/**" access="denyAll" />
		<security:form-login />
		</security:http>

At this point, if we run the webapplication, spring will automatically generate a login form and even if you give the correct credential it will deny access.


If add the following code in the security-context.xml, under the proper security tags,
				<security:intercept-url pattern="/" access="permitAll" />
				<security:intercept-url pattern="/offers" access="permitAll" />
					then it will allow access to the root of the web page and the show offers web page and everything else will be denied.



Now to do everything that valid user is allowed to do we need to authenticate other webpages as well. so we have add the following isAuthenticated() access
to the following webpages as well. It looks like:

		<security:http use-expressions="true">
		<security:intercept-url pattern="/createoffer" access="isAuthenticated()" />
		<security:intercept-url pattern="/doCreate" access="isAuthenticated()" />
		<security:intercept-url pattern="/offerCreated" access="isAuthenticated()" />
		<security:intercept-url pattern="/" access="permitAll" />
		<security:intercept-url pattern="/offers" access="permitAll" />
		<security:intercept-url pattern="/**" access="denyAll" />
		<security:form-login />
		</security:http>

	Spring will execute the patterns from top to bottom and we need to put the denyAll at the end of the list, to deny the webpages that we might have
	missed otherwise.

	Upto this point, spring is not entertaining the static resources like CSS and also we are hard coding the user credentials. We will now make 
	the users credential come from the database and make the static resources active.



----------------------------------------------------------------------




Serving the static resources:
-----------------------------

We need to add the following line in the security tag to allow static contents.
			<security:intercept-url pattern="/static/**" access="permitAll" />

	If we go to the offers-servlet.xml, we will see,
		<mvc:resources location="/resources/" mapping="/static/**">
		</mvc:resources>

		The jsps have accessed the static resources as 
		<link href="${pageContext.request.contextPath}/static/css/main.css" rel="stylesheet" type="text/css">

		And we have used the same /static/** in the security tags in the security-context.xml file.



--------------------------------------------------------------------



Customizing the login form:
----------------------------

We need to create a login form of our own and tell spring to use that.
We are gonna go to the default spring login form and do the view source as we are gonna need some controls and naming.

The view source looks like:

	<html><head><title>Login Page</title></head><body onload='document.f.j_username.focus();'>
	<h3>Login with Username and Password</h3><form name='f' action='/KushalDynamicWebApp/j_spring_security_check' method='POST'>
	 <table>
	    <tr><td>User:</td><td><input type='text' name='j_username' value=''></td></tr>
	    <tr><td>Password:</td><td><input type='password' name='j_password'/></td></tr>
	    <tr><td colspan='2'><input name="submit" type="submit" value="Login"/></td></tr>
	  </table>
	</form></body></html>


Now we create login.jsp file in the jsps folder and paste the above code as a basis for it.

We change the url path to action='${pageContext.request.contextPath}/j_spring_security_check' and also paste the css file from the createoffer.jsp
we can modify that in the login form.
Do whatever css edits you wanna make here.

Now we need to make a mapping for the url and this jsp page, so we need to make a somekind of controller to handle the mapping.

We are gonna make a different class in the controller package to handle the login based controller even though it is just one. We
add something like this in the login controller:
			@Controller
			public class LoginController {
				@RequestMapping("/login")
				public String showLogin(){
					return "login";
				}
			}

		Also add the /login as the permit all in the security-context.xml file. Finally we need to tell spring to use this login form insted.

		for that go to the sec tab in the security-context.xml and expand the http bean and click on the form-login and on the right,
		enter /login for the login-page option.
		It looks like <security:form-login login-page="/login" /> in the source code.


	It works !!

	Now if you notice that if you enter some garbage in the login form, it will show no error message because we have not entertained the
	error handling in our custom login form.





Displaying the login error in the custom login form:
-----------------------------------------------------

We are gonna do something clever to handle the error messages. In the same form-login tag, on the right there is something called
authenticataion-failure-url and in there we are gonna paste as, /login?error=true, which simply is gonna redirect to the same login page but
with a parameter called error set to true. Then in the login page, we do something like, if the error parameter is true, do something more than that.
This is clever.

<security:form-login login-page="/login"
authentication-failure-url="/login?error=true" />


In the login.jsp we are gonna use some jstl core tags to access the error variable. To use the jstl, we need to use the jstl taglib. We can just copy the 
taglib from the home.jsp (<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>)


if you just type <c:if and hit ctrl+space it will auto complete. And we can insert something like:
	
		<c:if test="${param.error!=null}">
		<p class="loginerror">Login failed. User name and password do not
			match out database. Please try again</p>
		</c:if>
And also update the css file for the loginerror class tag.




Authorizing users from the database:
-------------------------------------
We are gonna use the existing MySQL database to store the credentials of the user to authenticated.
In the security-context.xml, we need another authentication provider to have user from the database.
In the sec tab, we are gonna add one more authentication provider and right click it and this time add, jdbc-user-service.
Now all I need to do is, in the right side of the screen, I need to add the datasource ref.

If you check the dao-context.xml file, we have a bean with id= dataSource to connect to the database. So here also we are gonna use the same
bean to connect to the database. In the data-source-ref we are gonna enter dataSource. It will look like:

	<security:authentication-manager>
		<security:authentication-provider>
			<security:user-service>
				<security:user name="Kushal" authorities="admin"
					password="letmein" />
				<security:user name="John" authorities="admin"
					password="passmein" />
			</security:user-service>
		</security:authentication-provider>
		<security:authentication-provider>
			<security:jdbc-user-service data-source-ref="dataSource" />
		</security:authentication-provider>
	</security:authentication-manager>


Now in the MySQL we have also added two new tables in the same springdatabase schema and named it users and authorities.
In users table we have columns like username, password and enabled, while in the authorities we have username and authority.
Spring-security dictates that the table has to be called users  and it should have the columns as username, password and enabled. The 
default value of the tuple in the enabled column should be 1.

Now we come back to the eclipse and right click the program and select run on server, it should work with no problem.
If you want to use your custom tables and names rather than the spring then there is option (authorities-by-username-query and users-by-username-query)
for that in the right side of the jdbc-user-service in the sec tab.



-------------------------------------------------------------


Creating an add user account form:
-----------------------------------

We need some kind of jsp to display the account creation form. So we copied the create offers jsp file and made a copy of it in the same jsp folder.
Finally we made some changes and it looks like:


<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
	pageEncoding="ISO-8859-1"%>
<%@ taglib prefix="sf" uri="http://www.springframework.org/tags/form"%>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link href="${pageContext.request.contextPath}/static/css/main.css"
	rel="stylesheet" type="text/css">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Create Account</title>
</head>

<body>

	<sf:form method="post"
		action="${pageContext.request.contextPath}/createaccount" commandName="offers"> //changed the form submit location

		<div id="formtable">
			<table>
				<tr>
					<td>UserName:</td>
					<td><sf:input path="username" name="username" type="text" /></td>
					<sf:errors path="username" cssClass="error" ></sf:errors>
				</tr>
				<tr>
					<td>Email:</td>
					<td><sf:input path="email" name="email" type="text" /></td>
					<sf:errors path="email" cssClass="error" ></sf:errors>
				</tr>
				<tr>
					<td>Password:</td>
					<td><sf:input path="password" name="password" type="text" /></td>
					<sf:errors path="password" cssClass="error" ></sf:errors>
				</tr>
				<tr>
					<td>Confirm Password:</td>
					<td><input name="confirmpass" type="text" /></td>
				</tr>
			
				<tr>
					<td><input id="submit" value="Submit" type="submit" /></td>
				</tr>
			</table>
		</div>
	</sf:form>


</body>
</html>



Now we need to work on the new mappings now. We need to have the create account mapping.

Now go the controller and login controller and make 2 copy of the existing showLogin method and modify it as:

// first one is for the new account creation and second one is for after the account is created.
	@RequestMapping("/newaccount")
	public String shownewaccount(){
		return "newaccount";
	}
	
	@RequestMapping("/createaccount")
	public String createAccount(){
		return "accountcreated";
	}
	// so we need to make a new jsp file called account created to handle this view resolver.

Now we need this form to be backed by somekind of bean object. In the newaccount.jsp file change the commandname from offers to user since
we just made a copy last time. Now we need to create a bean called user in the dao package. Make a class called user in the dao package.

In the User class we make the field like username, password, email (since we have this in the form), enabled and authority and also have getters and setter and also constructors using
field and also a default constructor.
It looks like:

package com.kushal.springframework.web.DAO;

public class User {

	private String username;
	private String password;
	private String email;
	private boolean enabled = false;
	private String authority;

	public User() {
	}

	public User(String username, String password, String email,
			boolean enabled, String authority) {
		this.username = username;
		this.password = password;
		this.email = email;
		this.enabled = enabled;
		this.authority = authority;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public boolean isEnabled() {
		return enabled;
	}

	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}

	public String getAuthority() {
		return authority;
	}

	public void setAuthority(String authority) {
		this.authority = authority;
	}

}



Now, when we display the new account form we need to have the User bean, so go to the login controller and modify the showNewAccount controller
as follows by adding a model and inserting the bean.

		@RequestMapping("/newaccount")
		public String showNewaccount(Model model){
			model.addAttribute("user", new User());
			return "newaccount";
		}
	
	Need to add pertaining imports hai.

Finally we need to add the newaccount, create account and accountcreated to the access rules. So we have add the following to the security-config.xml file

		<security:intercept-url pattern="/newaccount" access="permitAll" />
		<security:intercept-url pattern="/createaccount" access="permitAll" />
		<security:intercept-url pattern="/accountcreated" access="permitAll" />


Finally we will add a link to the new account webpage, in the login form. So we add the following codes to the login.jsp:

	<p>
		<a href='<c:url value="/newaccount"></c:url>'>Create New Account</a>
	</p>


It should work at this point :) cheers.


-----------------------------------------------------------------------



Making the create Account form work:
------------------------------------

Now we need user DAO.
It looks like :


package com.kushal.springframework.web.DAO;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component("usersDao")
public class UsersDAO {

	private NamedParameterJdbcTemplate jdbc;

	@Autowired
	public void setDataSource(DataSource jdbc) {
		this.jdbc = new NamedParameterJdbcTemplate(jdbc);
	}

	@Transactional // we want both the tables to be successfully update not just one.
	public boolean create(User user) {

		BeanPropertySqlParameterSource params = new BeanPropertySqlParameterSource(user);
		
		jdbc.update("insert into users (username, password, email, enabled) values(:username, :password, :email, :enabled)",params);
		return jdbc.update("insert into authorities (username, authority) values(:username,:authority)",params) == 1;

	}
}


Now we need to work on the service layer. It will look like this:

package com.kushal.springframework.web.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.kushal.springframework.web.DAO.User;
import com.kushal.springframework.web.DAO.UsersDAO;

@Service("usersService")
public class UsersService {

	private UsersDAO usersDao;

	@Autowired
	public void setUsersDao(UsersDAO usersDao) {
		this.usersDao = usersDao;
	}

	public void create(User user) {
		usersDao.create(user);
	}

}



Now we go and fix the controller. We will copy the following code from the OffersController which is resposible for taking the values from the
form and putting it in the database.

	@RequestMapping(value = "/doCreate", method = RequestMethod.POST)
	public String doCreate(Model model, @Valid Offers offers,
			BindingResult result) {
		if (result.hasErrors()) {
			return "createoffer";
		}
		offersService.create(offers);
		return "offerCreated";
	}



	 and modify the stub method into this form  and the total login controller will look like:

	 package com.kushal.springframework.web.controllers;

import javax.validation.Valid;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.kushal.springframework.web.DAO.User;
import com.kushal.springframework.web.service.UsersService;

@Controller
public class LoginController {
	private UsersService usersService;

	@Autowired
	public void setUsersService(UsersService usersService) {
		this.usersService = usersService;
	}

	@RequestMapping("/login")
	public String showLogin() {
		return "login";
	}

	@RequestMapping("/newaccount")
	public String showNewaccount(Model model) {
		model.addAttribute("user", new User());
		return "newaccount";
	}

	@RequestMapping(value = "/createaccount", method = RequestMethod.POST)
	public String createAccount(@Valid User user, BindingResult result) {
		if (result.hasErrors()) {
			return "createaccount";
		}
		user.setEnabled(true);
		user.setAuthority("admin");
		usersService.create(user);
		return "accountcreated";
	}
}


Up to this point, we don't have the email column in the database, so we add it in the database as a new column.
Now if you re run it, it will be just fine, not a problem...user will be created in the database :) and can also login using the
newly created account. wow.



100: Adding validation to the User form:
-----------------------------------------

We have added some annotation in the User class to validate Username, email and password. It looks like:

	@NotBlank(message = "User name cannot be blank")
	@Size(min = 4, max = 15, message = "User name must be between 4 and 15")
	@Pattern(regexp = "^\\w{4,}", message = "User name can only contain alphanumeric and underscore")
	private String username;

	@NotBlank(message="Password cannot be blank")
	@Pattern(regexp = "^\\S+$", message="Password cannot contain spaces")
	@Size(min=4, max=8, message="Password must be between 4 and 8 char long")
	private String password;
	
	@Email(message="Not a valid email")  // this annotation is from hibernate
	private String email;
	private boolean enabled = false;
	private String authority;


These annotations will handle the validation of the new account form.
Now how about the handling of the duplicate usenname and keys in the database.



Handling the duplicate username:
---------------------------------

If there is a duplicate key i.e., username then there will be database exception and what we try to catch that exception. If we catch the 
exception, then we will return to the newaccount webpage. What we did is we figured out what exception is actually is thrown when there is a
duplicate key. It is duplicateKeyException. We will try to catch this exception in the logincontroller while creating the user. It looks like:

		@RequestMapping(value = "/createaccount", method = RequestMethod.POST)
		public String createAccount(@Valid User user, BindingResult result) {
			if (result.hasErrors()) {
				return "newaccount";
			}
			user.setEnabled(true);
			user.setAuthority("admin");
							try {
								usersService.create(user);
							} catch (DuplicateKeyException e) {
								result.rejectValue("username", "DuplicateKey.user.username", "UserName already exists !"); 
								//here username is the pathname in the form we created. Second argument is the way we do it. Some name followed by 
								// the class name and the error field. Third argument is the message for sf error in the form.
								return "newaccount";
							}
			return "accountcreated";
		}


However this way of relying on the catching exceptions to validate the username duplicacy is not so good. So we will add some more code and make
this method only the fallback plan.

@RequestMapping(value = "/createaccount", method = RequestMethod.POST)
	public String createAccount(@Valid User user, BindingResult result) {
		if (result.hasErrors()) {
			return "newaccount";
		}
		user.setEnabled(true);
		user.setAuthority("admin");
		
		//This bit of code is added and also needed to add the following code in the UserService and UserDao class
		if(usersService.exists(user.getUsername())){
			System.out.println("Duplicate username found...");
			result.rejectValue("username", "DuplicateKey.user.username", "UserName already exists !");
			return "newaccount";
		}
		
					try {
						usersService.create(user);
					} catch (DuplicateKeyException e) {
						result.rejectValue("username", "DuplicateKey.user.username", "UserName already exists !");
						return "newaccount";
					}
		return "accountcreated";
	}


UserService:

public boolean exists(String username) {
		return usersDao.exists(username);
	}


UserDAO:
	public boolean exists(String username) {
		return jdbc.queryForObject("select count(*) from users where username=:username", new MapSqlParameterSource("username", username), Integer.class)>0; 
	}

OR:

	public boolean exists(String username) {
		MapSqlParameterSource param = new MapSqlParameterSource();
		param.addValue("username", username);
		
		return jdbc.queryForObject("select count(*) from users where username=:username", param, Integer.class)>0; 
	}


This works:
Just fine. Cheers.


--------------------------------------------------------------------



Storing validation message in a property file:
----------------------------------------------

Up to now we have put the validation error message every where. Not a good practise. It is better to have them in one place. Suppose you website needs 
to be translated into a new language, then looking for error message all around the code is a headache. So we put them in one place, say property file.

So we create a new package for the messages called messages. There we'll have a file called messages.properties.
Now we need to add a bean in the offers-servlet.xml file. Go to the beans tab and right click the root bean and create a new bean and call it
messageSource and set it's class to ResourceBundleMessageSource. Next right click the bean just created and set the property and set the name as 
basename and value as the com.kushal.springframework.web.messages.messages (No need to add .properties)

Here basename is dictated by the ResourceBundleMessageSource jar file.

Now we got rid of the message from the field annotation in the User Class and put it in the messages.properties file. The way to enter in this file is:

	Size.user.username= your message here


	Here Size is the constraint, user is the lowercased class name and username is the field.

	This will work just fine. No problem


	The message.properties will look like this:

			Size.user.username = User name must be between 4 and 15.
			NotBlank.user.username = User name cannot be blank.
			Pattern.user.username = User name can only contain alphanumeric and underscore.

			Size.user.password = Password must be between 4 and 8 char long.
			NotBlank.user.password= Password cannot be blank.
			Pattern.user.password = Password cannot contain spaces.

			DuplicateKey.user.username = UserName already exists !